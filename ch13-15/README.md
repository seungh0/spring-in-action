# 13. 서비스 탐구하기

## 마이크로서비스

### 단일 애플리케이션의 문제점

- 전체를 파악하기 얿다
- 테스트가 어렵다
- 라이브러리 간에 충돌이 생기기 쉽다
- 확장 시에 비효율적이다.
- 적용할 테크놀러지를 결정할 떄도 애플리케이션 전체를 고려해야 한다.
- 프로덕션으로 이양하기 위해 많은 노력이 필요하다.

### 마이크로서비스

마이크로서비스 아키텍처는 개별적으로 개발되고 배포되는 소규모의 작은 애플리케이션들로 애플리케이션을 만드는 방법이다. 마이크로서비스는 상호 협력하여 더 큰 애플리케이션의 기능을 제공한다.

- 마이크로서비스는 쉽게 이해할 수 있다.
    - 다른 마이크로서비스와 협력할 때 각 마이크로서비스는 작으면서 한정된 처리를 수행한다.
    - 따라서 마이크로서비스는 자신의 목적에만 집중하므로 더 이해하기 쉽다.
- 마이크로서비스는 테스트가 쉽다.
- 마이크로서비스는 라이브러 비호환성 문제가 생기지 않는다.
    - 각 마이크로서비스는 다른 마이크로서비스와 공유되지 않는 빌드 의존성을 가지므로 라이브러리 충돌 문제가 생기지 않음.
- 마이크로서비스는 독자적으로 규모를 조정할 수 있다.
    - 만일 특정 마이크로서비스 규모가 더 커야 한다면, 애플리케이션의 다른 마이크로서비스에 영향을 주지 않고, 메모리 할다이나 인스턴스의 수를 더 크게 조정할 수 있다.
- 각 마이크로서비스에 적용할 테크놀러지를 다르게 선택할 수 있다.
    - 각 마이크로서비스에 사용할 프로그래밍 언어, 플랫폼, 프레임워크를 서로 다르게 선택할 수 있다.
- 마이크로서비스는 언제든 프로덕션으로 이양할 수 있다.
    - 각 마이크로서비스를 따로 배포할 수 있다.

### 마이크로서비스

- 마이크로서비스 아키텍처는 분산 아키텍처이므로 네트워크 지연과 같은 문제들이 발생할 수 있다.
- 마이크로서비스로의 원격 호출이 많이 추가될수록 애플리케이션의 실행은 더 느려질 수 있다.
- 애플리케이션으로 상대적으로 작거나 간단하다면 일단 단일 애플리케이션으로 개발하는 것이 좋다.
- 그리고 점차 규모가 커질때 마이크로서비스 아키텍처로 변경하는 것을 고려할 수 있다.

## 서비스 레지스트리 설정하기

### 유레카

- 마이크로서비스가 서로를 찾을 때 사용되는 서비스 레지스트리.
- 유레카는 마이크로서비스 애플리케이션에 있는 모든 서비스의 중앙 집중 레지스트리로 작동.
- 유레카 자체도 마이크로서비스로 생각할 수 있으며, 더 큰 애플리케이션에서 서로 다른 서비스들이 서로를 찾는 데 도움을 주는 것이 목적.
- 서비스 인스턴스가 시작될 때 해당 서비스는 자신의 이름을 유레카에 등록한다.
- 다음으로 등록된 여러 인스턴스 중 어떤 인스턴스를 사용할지, 클라이언트 측에서 동작하는 로드밸런싱 알고리즘이 적용한다.
- 이때 사용될 수 있는 것이 Ribbon.

### 클라이언트 측의 로드 밸런서를 사용하는 이유

- 로드 밸런스는 주로 단일의 중앙 집중화된 서비스가 서버 측에서 사용되었다.
- 하지만 이와는 반대로 리본은 클라이언트에서 실행되는 클라이언트 측의 로드 밸런서이다.

### 클라이언트 측의 로드 밸런서의 장점

- 각 클라이언언트에 하나의 로컬 로드 밸런서가 있으므로, 클라이언트의 수에 비례하여 자연스럽게 로드 밸런서의 크기가 조정된다.
- 또한, 서버에 연결된 모든 서비스에 획일적으로 같은 구성을 사용하는 대신, 로드 밸런서는 각 클라이언트에 가장 적합한 로드 밸런싱 알고리즘을 사용하도록 구성할 수 있음.

# 14. 클라우드 구성 관리

- 스프링 클라우드의 구성 서버는 애플리케이션의 모든 마이크로서비스에 대해 중앙 집중식의 구성을 제공한다.
- 따라서 구성 서버를 사용하면 애플리케이션의 모든 구성을 한 곳에서 관리할 수 있다.

## 구성 공유하기

### 기존의 구성 속성

- 구성 속성이 런타임 환경을 변경하거나 런타임 환경에 고유한 것이어야 한다면, 자바 시스템 속성이나 운영체제의 환경 변수를 구성 속성으로 사용하는 것이 좋다.
- 그러나 값이 변경될 가능성이 거의 없고, 애플리케이션에 특정되는 속성의 경우는 애플리케이션 패키지에 포맣되어 배포되는 application.yml, application.properties 파일에 구성 속성을
  지정하는 것이 좋은 선택.

### 문제점

- 이런 선택은 간단한 애플리케이션에서는 문제가 없다.
- 하지만 자바 시스템 속성이나 운영체제의 환경 변수에 구성 속성을 설정하는 경우는 해당 속성의 변경으로 인해 애플리케이션이 다시 시작되어야 한다는 것을 감안해야 함.
- 그리고 배포되는 JAR, WAR 파일 내부에 구석 속성을 포함시키는 경우는 해당 속성을 변경하거나 원래의 값을 되돌릴 때 애플리케이션을 다시 빌드하여 배포해야 함. => 속성만 변경하기 위해 애플리케이션을
  재배포하거나 재시작한다는 것은 매우 불편하며, 애플리케이션에 결함이 생길 수도 있음. 또한 다수의 배포 인스턴스에서 속성을 관리해야하는 마이크로서비스 기반 애플리케이션의 경우는 실행중인 애플리케이션의 모든 서비스
  인스턴스에 동일한 변경을 적용하는 것이 불합리함.

- 또한 보안에 민감한 속성 값은 각 애플리케이션의 속성에 지정될 때 암호화될 수 있지만, 사용 전에 해당 속성값을 복호화 하는 기능이 애플리케이션에 포함되어 있어야함. (운영체제의 환경 변수에 설정하는 것은
  바람직하지 않음.)

### 중앙 집중식으로 구성

- 구성이 더 이상 애플리케이션 코드에 패키징되어 배포되지 않음. 따라서 애플리케이션을 다시 빌드하거나 배포하지 않고 구성을 변경하거나 원래 값으로 환원할 수 있다. 또한 애플리케이션을 다시 시작하지 않아도 실행
  중에 구성을 변경할 수 있음.

- 공통적인 구성을 공유하는 마이크로서비스가 자신의 속성 설정으로 유지, 관리하지 않고도 동일한 속성들을 공유할 수 있다. 그리고 속성 변경이 필요함녀 한 곳에서 한번만 변경해도 모든 마이크로서비스에 적용 가능.
- 보안에 민감한 구성 속성은 애플리케이션 코드와는 별도로 암호화하고 유지.관리 할 수 있다. 그리고 복호화된 속성 값을 언제든지 애플리케이션에서 사용할 수 있으므로, 복호화하는 코드가 애플리케이션에 없어도 됨.

## 구성 서버 실행하기

<img src="https://t1.daumcdn.net/thumb/R720x0/?fname=http://t1.daumcdn.net/brunch/service/user/2MrI/image/X0wNHdxiHq2cCmffYdYT2vcEF9s.PNG">
- 구성 서버는 클라이언트가 되는 다른 서비스들이 구성 속성을 사용할 수 있도록 REST API를 제공한다.
- 구성 서버로 제공되는 구성 데이터는 구성 서버의 외부 (Git)에 저장된다.
- Git과 같은 소스 코드 제어 시스템에 구성 속성을 저장함으로써, 애플리케이션 소스 코드처럼 구성 속성의 버전, 분기 등을 관리할 수 있다.
- 그러나 구성 속성을 사용하는 애플리케이션과 별도로 구성 속성을 유지, 관리 하므로 애플리케이션과 독립저긍로 버전을 관리할 수 있다.

# 15. 실패와 지연 처리하기

## 서킷 브레이커 이해하기

- 서킷 브레이커 패턴은 우리가 작성한 코드가 실행에 실패하는 경우에 안전하게 처리되도록 해줌.
- 한 마이크로서비스의 실패가 다른 마이크로서비스의 연쇄적인 실패로 확산되는 것을 방지해야 하기 때문에, 마이크로서비스의 컨텍스트에서 훨씬 더 중요.

- 서킷 브레이커는 메소드 호출을 허용하며, 서킷은 닫힘 상태에서 시작, 그리고 메소드의 실행이 실패하면 서킷 브레이커가 개방되고 실패한 메소드에 대해 더 이상 호출이 수행되지 않는다.
- 그리고 서킷 브레이커는 폴백을 제공하여 자체적으로 실패를 처리한다.

- 서킷 브레이커는 메소드에 적용된다. 우리 코드의 어디에 서킷 브레이커를 선언할지 결정할 때는 실패의 대상이 되는 메소드를 식별하는 것이 중요.
- 다음 유형의 메소들이 서킷 브레이컬르 선언할 후보들.
    - REST를 호출하는 메소드
        - 사용할 수 없거나 500 에러를 반환하는 원격 서비스로 인해 실패할 수 있는 메소드.
    - 데이터베이스 쿼리르 수행하는 메소드
        - 데이터베이스가 무반응 상태가 되거나 애플리케이션을 중단시킬 수 있는 스키마의 변경이 생기면 실패할 수 있는 메소드.
    - 느리게 실행될 가능성이 있는 메소드
        - 반드시 실패하는 메소드가 아니다. 하지만 너무 오랫동안 실행된다면 비정상적인 상태를 고려할 수 있음.

- 1,2번 유형의 메소드는 서킷 브레이커의 실패 처리로 해결할 수 있음.
- 마지막 유형의 메소든느 실패보다는 지연이 문제되는 경우.

## Hystrix

- 서킷 브레이커 패턴을 자바로 구현한 라이브러리.
- Hystrix 서킷 브레이커는 대상 메소드가 실패할 때 폴백 메소드를 호출하는 Aspect로 구현된다.
- Aspect는 대상 메소드가 얼마나 자주 실패하는지도 추적한다.
- 실패율이 한계값을 초과하면, 모든 대상 메소드 호출을 폴백 멧도르 호출로 전달.
